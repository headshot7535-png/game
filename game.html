<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Vaultborn: Online Co-op</title>
<style>
  :root{--bg:#0a0b12;--panel:#121421;--acc:#7dd3fc;--good:#22c55e;--warn:#f59e0b;--bad:#ef4444}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0a0b12,#0a0a10);color:#e5e7eb;
       font:16px/1.3 system-ui,Segoe UI,Roboto,Ubuntu,Arial}
  #wrap{position:relative;height:100%}
  #game{display:block;width:100%;height:100%;
        background:radial-gradient(1000px 600px at 50% 60%,#0f1322,#0a0b12)}

  /* HUD */
  #hud{position:absolute;left:12px;top:56px;right:12px;display:flex;gap:12px;pointer-events:none}
  .card{background:rgba(18,20,33,.75);backdrop-filter:blur(6px);
        border:1px solid rgba(255,255,255,.06);border-radius:12px;
        padding:10px 12px;box-shadow:0 8px 30px rgba(0,0,0,.35)}
  .row{display:flex;gap:12px;align-items:center}
  .col{display:flex;flex-direction:column;gap:6px}
  #left{min-width:260px}
  #right{margin-left:auto;min-width:240px;text-align:right}
  .title{font-weight:700;letter-spacing:.3px}
  .bar{position:relative;width:100%;height:16px;background:#0b0d17;border-radius:10px;
       overflow:hidden;border:1px solid rgba(255,255,255,.06)}
  .hp{background:linear-gradient(90deg,#ef4444,#dc2626)}
  .shield{background:linear-gradient(90deg,#60a5fa,#3b82f6)}
  .xp{background:linear-gradient(90deg,#34d399,#10b981)}
  .tiny{font-size:12px;color:#9ca3af}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;
        border:1px solid rgba(255,255,255,.12);font-size:12px;color:#cbd5e1}

  #bottom{position:absolute;left:12px;right:12px;bottom:12px;display:flex;gap:12px;align-items:flex-end;pointer-events:none}
  #msg{margin-left:auto;max-width:46ch;text-align:right}
  .popup{position:absolute;left:50%;top:14%;transform:translateX(-50%);
         background:#121421cc;border:1px solid rgba(255,255,255,.1);
         padding:6px 10px;border-radius:8px;font-weight:600;animation:rise .9s ease-out forwards}
  @keyframes rise{from{opacity:0;transform:translate(-50%,10px)}to{opacity:1;transform:translate(-50%,-6px)}}
  #help{position:absolute;right:12px;bottom:140px;pointer-events:none;max-width:360px}
  @media(max-width:900px){#help{left:12px;right:auto;bottom:86px}}
  #help .card{max-width:360px}
  code{background:#0b0d17;padding:2px 6px;border-radius:6px}
  .btxt{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
        font-size:11px;font-weight:700;color:#e5e7eb;text-shadow:0 1px 0 rgba(0,0,0,.7);pointer-events:none}

  /* Overlay */
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:5}
  .modal{pointer-events:auto;max-width:860px;background:rgba(18,20,33,.92);
         border:1px solid rgba(255,255,255,.12);padding:16px;border-radius:14px;display:grid;gap:12px}
  .opt{border:1px solid rgba(255,255,255,.08);padding:10px;border-radius:10px;cursor:pointer}
  .opt:hover{border-color:#7dd3fc}
  .opts{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px}
  .actions{display:flex;gap:10px;justify-content:flex-end}
  button{background:#1f2340;border:1px solid rgba(255,255,255,.1);color:#e5e7eb;border-radius:10px;padding:8px 12px;cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}
  #menuBtn{position:absolute;left:12px;top:12px;z-index:6;pointer-events:auto}

  /* Ally HUD */
  #allyHUD{position:absolute;left:12px;top:180px;pointer-events:none;min-width:260px;display:none}

  /* Minimap */
  #minimap{position:absolute;right:12px;bottom:100px;border:1px solid rgba(255,255,255,.1);
           border-radius:10px;overflow:hidden;pointer-events:none}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="left" class="card col">
      <div class="row"><div class="title">Vaultborn</div><div id="mode" class="pill">Wave 1</div></div>
      <div class="tiny">Zone: Dust • Difficulty scales each wave</div>
      <div class="col">
        <div class="tiny">Health</div>
        <div class="bar"><div id="hpBar" class="hp" style="width:100%;height:100%"></div><div id="hpTxt" class="btxt">100/100</div></div>
        <div class="tiny">Shield</div>
        <div class="bar"><div id="shBar" class="shield" style="width:100%;height:100%"></div><div id="shTxt" class="btxt">50/50</div></div>
        <div class="tiny">XP</div>
        <div class="bar"><div id="xpBar" class="xp" style="width:0;height:100%"></div><div id="xpTxt" class="btxt">0/100</div></div>
      </div>
    </div>

    <div id="mid" class="card col" style="min-width:320px">
      <div class="row"><div class="title">Weapon</div><div id="slot" class="pill">Slot 1</div></div>
      <div id="wName">Starter Pistol [Common]</div>
      <div class="tiny" id="wStats">DMG 8 • RPM 420 • Spread 2° • DPS 56</div>
    </div>

    <div id="right" class="card col">
      <div class="title">Wave</div>
      <div id="wave">1</div>
      <div class="tiny">Enemies left: <span id="leftCount">0</span></div>
      <div class="tiny">Coins: <span id="coins">0</span></div>
    </div>
  </div>

  <button id="menuBtn" class="card tiny">Menu</button>

  <div id="allyHUD" class="card col">
    <div class="row"><div class="title" id="allyName">Ally</div><div class="pill">Online</div></div>
    <div class="tiny">Health</div>
    <div class="bar"><div id="hpBar2" class="hp" style="width:100%;height:100%"></div><div id="hpTxt2" class="btxt">100/100</div></div>
    <div class="tiny">Shield</div>
    <div class="bar"><div id="shBar2" class="shield" style="width:100%;height:100%"></div><div id="shTxt2" class="btxt">50/50</div></div>
  </div>

  <div id="help">
    <div class="card tiny">
      <b>Controls</b>: WASD + mouse (LMB fire, Q grenade, E dash, F loot) • 1/2 swap • P pause • T talents • B buyback teammate • X reset save •
      <b>Online:</b> Menu → Online → Host/Join with 6-char Invite Code
    </div>
  </div>

  <div id="bottom">
    <div id="lootHint" class="card tiny" style="opacity:0">Press <code>F</code> to pick up</div>
    <div id="msg" class="card tiny">Defeat enemies to drop loot. Beat Wave 5 to unlock Endless Rift.</div>
  </div>

  <canvas id="minimap" width="180" height="120"></canvas>
</div>

<div id="overlay"><div class="modal" id="modal"></div></div>
<script>
(() => {
  // Utils
  const rand=(a,b)=>Math.random()*(b-a)+a, rint=(a,b)=>Math.floor(rand(a,b+1)), clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now()/1000, lerp=(a,b,t)=>a+(b-a)*t, dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy};
  const chance=(p)=>Math.random()<p;

  // Canvas
  const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
  function resize(){ canvas.width=innerWidth*devicePixelRatio; canvas.height=innerHeight*devicePixelRatio; ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
  addEventListener('resize',resize,{passive:true}); resize();

  // Audio
  const AudioCtx=window.AudioContext||window.webkitAudioContext; const ac=new AudioCtx(); let sfxOn=true;
  function beep(freq=440,dur=0.05,type='square',gain=0.02){ if(!sfxOn) return; const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+dur); }

  // Loot / Guns
  const rarities=[{n:'Common',c:'#c8c8c8',w:45,mult:1},{n:'Uncommon',c:'#7ccc7c',w:30,mult:1.15},{n:'Rare',c:'#5b8be0',w:15,mult:1.35},{n:'Epic',c:'#aa5ae0',w:7,mult:1.6},{n:'Legendary',c:'#ffae28',w:2,mult:2.0},{n:'Mythic',c:'#ff3c3c',w:1,mult:2.5}];
  const types=[{n:'Pistol',rpm:420,dmg:8,spread:2,pellets:1,speed:900},{n:'SMG',rpm:720,dmg:6,spread:3,pellets:1,speed:900},{n:'AR',rpm:540,dmg:10,spread:2.2,pellets:1,speed:1050},{n:'Shotgun',rpm:90,dmg:14,spread:7,pellets:8,speed:900},{n:'Sniper',rpm:60,dmg:65,spread:0.5,pellets:1,speed:1400},{n:'Launcher',rpm:40,dmg:85,spread:1.5,pellets:1,speed:700,aoe:90}];
  const prefixes=['Rusty','Makeshift','Field','Tuned','High-End','Vaultborn'], suffixes=['of Sparks','of Embers','of Acid','of Frost','of Ruin','of Echoes'];
  const weightedPick=(list,key='w')=>{const tot=list.reduce((s,x)=>s+(x[key]||1),0); let r=Math.random()*tot; for(const x of list){ r-=(x[key]||1); if(r<=0) return x; } return list[list.length-1];};
  function rollWeapon(level){ const t=types[rint(0,types.length-1)], r=weightedPick(rarities), mult=r.mult;
    const w={ id:Math.random().toString(36).slice(2), type:t.n, name:`${prefixes[rint(0,prefixes.length-1)]} ${t.n} ${suffixes[rint(0,suffixes.length-1)]}`,
      rarity:r.n, rColor:r.c, dmg:Math.floor(t.dmg*(0.9+Math.random()*0.2)*(1+level*0.05)*mult),
      rpm:Math.floor(t.rpm*(0.9+Math.random()*0.2)), spread:t.spread, pellets:t.pellets||1, speed:t.speed, aoe:t.aoe||0,
      crit:0.05+Math.random()*0.15, critM:1.5+Math.random()*0.8,
      mag:t.n==='Shotgun'?6:(t.n==='Sniper'?5:(t.n==='Launcher'?3:(t.n==='SMG'?30:(t.n==='AR'?24:15)))),
      reload:t.n==='Shotgun'?0.7:(t.n==='Sniper'?2.4:(t.n==='Launcher'?3.2:(t.n==='SMG'?1.6:(t.n==='AR'?2.0:1.4))) }
    w.maxMag=w.mag; w.upMult=1; return w;
  }
  const dps=(w)=>Math.round((w.dmg*w.upMult*(1+(w.crit*w.critM)))*(w.rpm/60)*w.pellets);

  // DOM helpers
  const $=id=>document.getElementById(id);
  const hpBar=$('hpBar'), shBar=$('shBar'), xpBar=$('xpBar'), wName=$('wName'), wStats=$('wStats'), slotLbl=$('slot'),
        waveLbl=$('wave'), leftLbl=$('leftCount'), coinsLbl=$('coins'), modeLbl=$('mode'),
        lootHint=$('lootHint'), msg=$('msg'), hpTxt=$('hpTxt'), shTxt=$('shTxt'), xpTxt=$('xpTxt');
  const allyHUD=$('allyHUD'), hpBar2=$('hpBar2'), shBar2=$('shBar2'), hpTxt2=$('hpTxt2'), shTxt2=$('shTxt2');
  const minimap=$('minimap'), mctx=minimap.getContext('2d');

  function setWeaponUI(w,slot=1){ wName.textContent=`${w.name} [${w.rarity}]`; wName.style.color=w.rColor;
    wStats.textContent=`DMG ${Math.round(w.dmg*w.upMult)} • RPM ${Math.round(w.rpm*(1+(mods.rof||0)))} • Spread ${w.spread}° • DPS ${dps(w)}`;
    slotLbl.textContent=`Slot ${slot}`; }
  function popup(text,color){ const p=document.createElement('div'); p.className='popup'; p.textContent=text; if(color) p.style.color=color; document.body.appendChild(p); setTimeout(()=>p.remove(),1000); }

  // Overlay & Menu
  let paused=false;
  const overlay=$('overlay'), modal=$('modal');
  function openOverlay(html,onClose){ modal.innerHTML=html; overlay.style.display='flex'; paused=true; const x=modal.querySelector('[data-close]'); if(x) x.addEventListener('click',()=>closeOverlay(onClose)); }
  function closeOverlay(cb){ overlay.style.display='none'; paused=false; if(cb) cb(); }
  $('menuBtn').addEventListener('click',()=>{
    if(dead) return;
    openOverlay(`<div class='row'><div class='title'>Menu</div><div class='pill'>Wave ${wave}</div></div>
      <div class='opts'>
        <div class='opt' id='optOnline'><div class='title'>Online</div><div class='tiny'>Invite code co-op.</div></div>
        <div class='opt' id='optSettings'><div class='title'>Settings</div><div class='tiny'>SFX, screen shake, auto-pickup.</div></div>
      </div>
      <div class='actions'><button data-close>Close</button></div>`);
    modal.querySelector('#optOnline').onclick=onlineMenu;
    modal.querySelector('#optSettings').onclick=settingsMenu;
  });
  function settingsMenu(){ openOverlay(`<div class='row'><div class='title'>Settings</div></div>
    <div class='opts'>
      <div class='opt'><label><input type='checkbox' id='sfx' ${sfxOn?'checked':''}/> Enable SFX</label></div>
      <div class='opt'><label><input type='checkbox' id='shake' checked/> Screen shake</label></div>
      <div class='opt'><label><input type='checkbox' id='auto'/> Auto-pickup loot</label></div>
    </div>
    <div class='actions'><button data-close>Done</button></div>`);
    modal.querySelector('#sfx').onchange=e=>{ sfxOn=e.target.checked; save(); };
    modal.querySelector('#shake').onchange=e=>{ shakeOn=e.target.checked; };
    modal.querySelector('#auto').onchange=e=>{ autoPickup=e.target.checked; };
  });

  // Character, classes & talents
  const mods = { dmg:0, rof:0, lifesteal:0, dropPlus:0, shieldFlat:0, dmgRes:0, grenadeAoe:0, grenadeCD:1, dashMult:1, crit:0, spdMult:1 };
  let myName='Player', myClass='Gunner', talentPts=0, talents={};
  const CLASSES={
    Gunner:{desc:'Damage/Ammo', passive:(p)=>{mods.dmg+=0.10;}, talents:[
      {id:'rf',name:'Rapid Fire',desc:'+7% fire rate / rank',max:3,apply:(r)=>{mods.rof+=0.07*r;}},
      {id:'hp',name:'Hollow Points',desc:'+8% weapon dmg / rank',max:3,apply:(r)=>{mods.dmg+=0.08*r;}},
      {id:'ls',name:'Leech',desc:'+1% lifesteal / rank',max:3,apply:(r)=>{mods.lifesteal+=0.01*r;}}
    ]},
    Guardian:{desc:'Tank/Shield', passive:(p)=>{mods.shieldFlat+=30; mods.dmgRes+=0.06;}, talents:[
      {id:'bulw',name:'Bulwark',desc:'+20 shield / rank',max:3,apply:(r)=>{mods.shieldFlat+=20*r;}},
      {id:'aegis',name:'Aegis',desc:'+2 shield regen / rank',max:3,apply:(r)=>{p.shRegen+=2*r;}}
    ]},
    Rogue:{desc:'Crit/Mobility', passive:(p)=>{mods.spdMult*=1.15; mods.crit+=0.05;}, talents:[
      {id:'haste',name:'Haste',desc:'-15% dash CD / rank',max:3,apply:(r)=>{mods.dashMult*=(1-0.15*r);}},
      {id:'crit',name:'Critical',desc:'+8% crit / rank',max:3,apply:(r)=>{mods.crit+=0.08*r;}}
    ]},
    Arcanist:{desc:'Explosives', passive:(p)=>{mods.grenadeAoe+=0.25; mods.grenadeCD*=0.9;}, talents:[
      {id:'boom',name:'Bigger Booms',desc:'+25% grenade radius / rank',max:3,apply:(r)=>{mods.grenadeAoe+=0.25*r;}},
      {id:'mix',name:'Quickmix',desc:'-20% grenade CD / rank',max:2,apply:(r)=>{mods.grenadeCD*=(1-0.20*r);}}
    ]},
  };
  function resetMods(){ mods.dmg=0; mods.rof=0; mods.lifesteal=0; mods.dropPlus=(mods.dropPlus||0); mods.shieldFlat=0; mods.dmgRes=0; mods.grenadeAoe=0; mods.grenadeCD=1; mods.dashMult=1; mods.crit=0; mods.spdMult=1; }
  function applyTalents(){
    resetMods();
    const cls=CLASSES[myClass]||CLASSES.Gunner;
    if(cls.passive) cls.passive(player);
    if(cls.talents) for(const t of cls.talents){ const r=talents[t.id]||0; if(r>0&&t.apply) t.apply(r, player); }
    if(typeof player.maxHpBase!=='number') player.maxHpBase=player.maxHp;
    if(typeof player.maxShBase!=='number') player.maxShBase=player.maxSh;
    player.maxHp = player.maxHpBase;
    player.maxSh = player.maxShBase + Math.round(mods.shieldFlat||0);
    if(player.sh>player.maxSh) player.sh=player.maxSh;
    setWeaponUI(player.guns[player.slot-1], player.slot);
  }
  function loadProfile(){ try{ const raw=localStorage.getItem('vaultborn_profile'); if(raw){ const p=JSON.parse(raw); myName=p.name||'Player'; myClass=p.cls||'Gunner'; talents=p.talents||{}; talentPts=p.talentPts||0; } }catch{} }
  function saveProfile(){ try{ localStorage.setItem('vaultborn_profile', JSON.stringify({name:myName, cls:myClass, talents, talentPts})); }catch{} }
  function ensureProfile(start){
    loadProfile();
    if(myName && myClass){ start(); return; }
    openOverlay(`<div class='row'><div class='title'>Create Character</div></div>
      <label class='tiny'>Name</label>
      <input id='pname' placeholder='Vaultborn' style='background:#0b0d17;color:#e5e7eb;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:6px 8px'>
      <label class='tiny'>Choose Class</label>
      <div class='opts'>${Object.keys(CLASSES).map(c=>`<div class='opt classOpt' data-c='${c}'><div class='title'>${c}</div><div class='tiny'>${CLASSES[c].desc}</div></div>`).join('')}</div>
      <div class='actions'><button id='create'>Start</button></div>`);
    let sel='Gunner';
    modal.querySelectorAll('.classOpt').forEach(el=>{ el.onclick=()=>{ sel=el.dataset.c; modal.querySelectorAll('.classOpt').forEach(x=>x.style.borderColor='rgba(255,255,255,.08)'); el.style.borderColor='#7dd3fc'; }; });
    modal.querySelector('#create').onclick=()=>{
      const n=(document.getElementById('pname').value||'').trim();
      myName=n||'Vaultborn'; myClass=sel; talents={}; talentPts=0; saveProfile(); closeOverlay(start);
    };
  }

  // Entities
  const world={w:2400,h:2400};
  const basePlayer=()=>({x:world.w/2,y:world.h/2, spd:280, r:14,
    hp:100, maxHp:100, maxHpBase:100, sh:50, maxSh:50, maxShBase:50, shCD:0, shRegen:12,
    coins:0, xp:0, level:1, nextXP:100, slot:1,
    guns:[rollWeapon(1), rollWeapon(1)], fireCD:0, reloadCD:0, dashCD:0, grenadeCD:0, invul:0});
  const player=basePlayer(); setWeaponUI(player.guns[0],1);
  let ally=null;

  const enemies=[], bullets=[], ebullets=[], loots=[], effects=[]; let pings=[];
  let wave=1, left=0, endless=false, bossWave=false, dead=false, remoteDown=false, reviveCost=100, revivesBought=0;
  let shake=0, shakeOn=true, autoPickup=false;

  // Save/Load
  function pickPlayer(p){ return {coins:p.coins,xp:p.xp,level:p.level,nextXP:p.nextXP,maxHp:p.maxHp,hp:p.hp,maxSh:p.maxSh,sh:p.sh,shRegen:p.shRegen,slot:p.slot, guns:p.guns.map(g=>({...g}))}; }
  function save(){ const data={wave, endless, bossWave, left, settings:{sfxOn, shakeOn, autoPickup}, player: pickPlayer(player)}; localStorage.setItem('vaultborn_save', JSON.stringify(data)); }
  function load(){ const raw=localStorage.getItem('vaultborn_save'); if(!raw) return; try{ const d=JSON.parse(raw);
      wave=d.wave||1; endless=!!d.endless; bossWave=!!d.bossWave; left=d.left||0;
      if(d.settings){ sfxOn=d.settings.sfxOn; shakeOn=d.settings.shakeOn; autoPickup=d.settings.autoPickup; }
      Object.assign(player, d.player||{}); setWeaponUI(player.guns[player.slot-1], player.slot); popup('Save loaded','#7dd3fc'); }catch{} }
  load();
  // Waves
  function spawnEnemy(level){ const side=rint(0,3); const pad=120; let x,y;
    if(side===0){x=pad;y=rand(pad,world.h-pad)} else if(side===1){x=world.w-pad;y=rand(pad,world.h-pad)}
    else if(side===2){x=rand(pad,world.w-pad);y=pad} else {x=rand(pad,world.w-pad);y=world.h-pad}
    enemies.push({x,y,r:14+rand(-2,8), hp:60+level*22, max:60+level*22, spd:80+level*2.2, level, t:0});
  }
  function spawnBoss(level){ const x=world.w/2+rand(-300,300), y=world.h/2+rand(-300,300); enemies.push({boss:true,x,y,r:30,hp:1200+level*120,max:1200+level*120, spd:90, t:0, atk:0}); left=1; }
  function spawnWave(){
    enemies.length=0; ebullets.length=0;
    bossWave = (!endless && wave%5===0) || (endless && wave%6===0);
    if(bossWave){ left=1; waveLbl.textContent=wave; modeLbl.textContent='BOSS'; spawnBoss(Math.min(60,5+wave*2)); }
    else{ const base=(8+wave*2)*(ally?1.5:1); left=Math.floor(base); waveLbl.textContent=wave; modeLbl.textContent=endless?'Rift':`Wave ${wave}`;
      const level=Math.min(60, 1+Math.floor(wave*0.8)); for(let i=0;i<base;i++) spawnEnemy(level); }
    save();
  }

  // Level/Perks/Shop
  function addXP(a){ player.xp += a; const need=player.nextXP;
    if(player.xp>=need){ player.xp-=need; player.level++; talentPts++; saveProfile(); player.nextXP=Math.round(need+50+player.level*25);
      popup(`Level ${player.level} +1`, '#34d399'); openPerkDraft(()=>{ const ng=rollWeapon(player.level);
        if(player.guns.length<2) player.guns.push(ng); setWeaponUI(player.guns[player.slot-1], player.slot); save(); }); }
    xpBar.style.width = `${Math.floor(100*player.xp/player.nextXP)}%`; xpTxt.textContent=`${Math.floor(player.xp)}/${player.nextXP}`;
  }
  const PERKS=[
    {id:'power',name:'Power Shot',desc:'+15% weapon damage',apply:()=>mods.dmg+=0.15},
    {id:'overclock',name:'Overclock',desc:'+20% fire rate',apply:()=>mods.rof+=0.20},
    {id:'vamp',name:'Vampiric Rounds',desc:'Heal 2% of damage dealt',apply:()=>mods.lifesteal+=0.02},
    {id:'thick',name:'Thick Shield',desc:'+25 Max Shield & refill',apply:()=>{player.maxSh+=25; player.sh=player.maxSh;}},
    {id:'regen',name:'Regen Coils',desc:'+4 shield regen/sec',apply:()=>player.shRegen+=4},
    {id:'lucky',name:'Lucky Finder',desc:'+8% drop chance',apply:()=>mods.dropPlus=(mods.dropPlus||0)+0.08},
    {id:'jug',name:'Juggernaut',desc:'+25 Max HP & heal',apply:()=>{player.maxHp+=25; player.hp=Math.min(player.maxHp, player.hp+25);}},
  ];
  function pick(arr,n){ const a=[...arr]; const out=[]; for(let i=0;i<n&&a.length;i++) out.push(a.splice(rint(0,a.length-1),1)[0]); return out; }
  function openPerkDraft(after){ const opts=pick(PERKS,3);
    const html=`<div class="row"><div class="title">Level Up — Choose a Perk</div><div style="margin-left:auto" class="pill">Lvl ${player.level}</div></div>
      <div class="opts">${opts.map((p,i)=>`<div class='opt' data-i='${i}'><div class='title'>${p.name}</div><div class='tiny'>${p.desc}</div></div>`).join('')}</div>
      <div class='actions'><button data-close>Skip</button></div>`;
    openOverlay(html, after);
    modal.querySelectorAll('.opt').forEach(el=>el.addEventListener('click',()=>{ const i=+el.dataset.i; opts[i].apply(); popup(opts[i].name,'#7dd3fc'); closeOverlay(after); setWeaponUI(player.guns[player.slot-1], player.slot); save(); }));
  }
  function openShop(after){ const g=player.guns[player.slot-1];
    const html=`<div class='row'><div class='title'>Between Waves — Shop</div><div class='pill'>Coins ${player.coins}</div></div>
      <div class='opts'>
        <div class='opt' id='heal'><div class='title'>Heal to Full — 30</div><div class='tiny'>Restore HP & Shield.</div></div>
        <div class='opt' id='reroll'><div class='title'>Reroll Current Gun — 40</div><div class='tiny'>Replace ${g.name} with a new drop.</div></div>
        <div class='opt' id='upgrade'><div class='title'>Upgrade Gun — 25</div><div class='tiny'>+10% damage (stacks).</div></div>
      </div>
      <div class='actions'><button data-close>Next Wave</button></div>`;
    openOverlay(html, after);
    modal.querySelector('#heal').onclick=()=>{ if(player.coins<30) return; player.coins-=30; player.hp=player.maxHp; player.sh=player.maxSh; coinsLbl.textContent=player.coins; popup('Healed','#34d399'); save(); modal.querySelector('.pill').textContent=`Coins ${player.coins}`; };
    modal.querySelector('#reroll').onclick=()=>{ if(player.coins<40) return; player.coins-=40; const ng=rollWeapon(player.level); player.guns[player.slot-1]=ng; setWeaponUI(ng, player.slot); coinsLbl.textContent=player.coins; popup('Rerolled','#7dd3fc'); save(); modal.querySelector('.pill').textContent=`Coins ${player.coins}`; };
    modal.querySelector('#upgrade').onclick=()=>{ if(player.coins<25) return; player.coins-=25; g.upMult=(g.upMult||1)*1.10; setWeaponUI(g, player.slot); coinsLbl.textContent=player.coins; popup('Upgraded +10%','#f59e0b'); save(); modal.querySelector('.pill').textContent=`Coins ${player.coins}`; };
  }

  // Input & talents UI
  const keys={}, mouse={x:0,y:0,down:false};
  addEventListener('keydown',e=>{
    const k=e.key.toLowerCase(); keys[k]=true;
    if(k==='p' && !dead && overlay.style.display!=='flex'){ paused=!paused; }
    if(k==='x'){ localStorage.removeItem('vaultborn_save'); popup('Save cleared','#ef4444'); }
    if(k==='t'){ openTalents(); }
    if(k==='b'){ if(remoteDown) buybackTeammate(); }
  });
  addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
  canvas.addEventListener('mousemove',e=>{ const r=canvas.getBoundingClientRect(); mouse.x=e.clientX-r.left; mouse.y=e.clientY-r.top; });
  canvas.addEventListener('mousedown',()=>{ mouse.down=true; ac.resume(); });
  canvas.addEventListener('mouseup',()=>{ mouse.down=false; });

  function openTalents(){
    const cls=CLASSES[myClass];
    openOverlay(`<div class='row'><div class='title'>${myClass} — Talents</div><div class='pill'>Points ${talentPts}</div></div>
      <div class='opts'>${cls.talents.map(t=>`<div class='opt tnode' data-id='${t.id}'><div class='title'>${t.name} <span class='rank'>${(talents[t.id]||0)}/${t.max}</span></div><div class='tiny'>${t.desc}</div></div>`).join('')}</div>
      <div class='actions'><button data-close>Close</button></div>`);
    modal.querySelectorAll('.tnode').forEach(el=>{
      el.onclick=()=>{ const id=el.dataset.id; const t=cls.talents.find(x=>x.id===id); const cur=talents[id]||0;
        if(cur>=t.max||talentPts<=0) return;
        talents[id]=cur+1; talentPts--; applyTalents(); saveProfile();
        el.querySelector('.rank').textContent=`${talents[id]}/${t.max}`; modal.querySelector('.pill').textContent=`Points ${talentPts}`;
      };
    });
  }

  // Combat helpers
  function fire(actor){
    const g=actor.guns[actor.slot-1]; if(!g || actor.reloadCD>0 || actor.fireCD>0) return;
    if(g.mag<=0){ actor.reloadCD=g.reload; if(actor===player) popup('Reloading…','#93c5fd'); return; }
    const a=Math.atan2(mouse.y-(actor.y-cam.y), mouse.x-(actor.x-cam.x));
    const spr=g.spread*(Math.PI/180); const shots=g.pellets||1;
    for(let i=0;i<shots;i++){ const aa=a+rand(-spr,spr);
      bullets.push({src:actor===ally?'ally':'me',x:actor.x,y:actor.y,vx:Math.cos(aa)*g.speed,vy:Math.sin(aa)*g.speed,
        dmg:(g.dmg*g.upMult)*(1+(Math.random()<g.crit?g.critM:0))*(1+mods.dmg),aoe:g.aoe||0,life:1.4}); }
    g.mag--; actor.fireCD = (60/(g.rpm*(1+(mods.rof||0)))); if(actor===player) beep(900,0.03,'square',0.015);
  }
  function explode(x,y,r,dmg,src){ effects.push({x,y,t:0,kind:'boom'}); if(shakeOn) shake=8;
    let totalDealt=0;
    for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; const d2=dist2(x,y,e.x,e.y); if(d2<=r*r){ 
      const dd=dmg*(1-d2/(r*r)); e.hp -= dd; totalDealt+=dd; if(e.hp<=0) killEnemy(i,true); 
    }}
    if(src==='me' && mods.lifesteal>0){ const heal=totalDealt*mods.lifesteal*0.2; let r=heal;
      const addS=Math.min(player.maxSh-player.sh, r); player.sh+=addS; r-=addS; player.hp=clamp(player.hp+r,0,player.maxHp); 
    }
  }
  function throwGrenade(actor){ if(actor.grenadeCD>0) return; actor.grenadeCD=10*(mods.grenadeCD||1);
    const a=Math.atan2(mouse.y-(actor.y-cam.y), mouse.x-(actor.x-cam.x)); const sp=420;
    const g={x:actor.x,y:actor.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,t:0}; effects.push({kind:'nade',obj:g});
    setTimeout(()=>explode(g.x,g.y,120*(1+(mods.grenadeAoe||0)),110+actor.level*6,'me'),420);
  }
  function dash(actor){ if(actor.dashCD>0) return; actor.dashCD=4*(mods.dashMult||1); actor.invul=0.35;
    const a=Math.atan2(mouse.y-(actor.y-cam.y), mouse.x-(actor.x-cam.x)); actor.x+=Math.cos(a)*140; actor.y+=Math.sin(a)*140; if(actor===player) popup('Dash','#a78bfa'); }

  // Online (WebRTC) + buyback
  const SIGNAL_URL="wss://vaultborn-signal.onrender.com";
  let rtc=null, chan=null, ws=null, role=null, currentCode=null;
  function mkCode(){ const chars='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let c=''; for(let i=0;i<6;i++) c+=chars[Math.floor(Math.random()*chars.length)]; return c; }
  function waitICE(pc){ if(pc.iceGatheringState==='complete') return Promise.resolve(); return new Promise(res=>{ const on=()=>{ if(pc.iceGatheringState==='complete'){ pc.removeEventListener('icegatheringstatechange',on); res(); } }; pc.addEventListener('icegatheringstatechange',on); }); }
  function connectSignal(){ return new Promise((resolve,reject)=>{ try{ if(ws && ws.readyState===1){ resolve(); return; } ws=new WebSocket(SIGNAL_URL); ws.onopen=resolve; ws.onerror=reject; ws.onmessage=(ev)=>{ try{ handleSignal(JSON.parse(ev.data)); }catch{} }; }catch(e){ reject(e); } }); }
  function sendSig(o){ if(ws && ws.readyState===1) ws.send(JSON.stringify(o)); }
  function makeRTC(){ const pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]}); if(role==='host'){ chan=pc.createDataChannel('v'); wireChannel(); } else { pc.ondatachannel=(e)=>{ chan=e.channel; wireChannel(); }; } return pc; }
  function wireChannel(){ chan.onopen=()=>{ popup('Online connected','#34d399'); if(!ally){ ally=basePlayer(); allyHUD.style.display='block'; } try{ chan.send(JSON.stringify({t:'hello',name:myName,cls:myClass})); }catch{} };
    chan.onmessage=(ev)=>{ let m; try{ m=JSON.parse(ev.data); }catch{ return; }
      if(m.t==='hello'){ $('allyName').textContent=m.name||'Ally'; if(!ally){ ally=basePlayer(); allyHUD.style.display='block'; } }
      else if(m.t==='pos'){ if(!ally){ ally=basePlayer(); allyHUD.style.display='block'; } ally.x=m.x; ally.y=m.y; ally.hp=m.hp; ally.sh=m.sh; }
      else if(m.t==='down'){ remoteDown=true; allyHUD.style.display='none'; popup('Teammate down! Press B to buy back ('+reviveCost+')', '#f59e0b'); }
      else if(m.t==='revive'){ if(dead) reviveSelf(); remoteDown=false; allyHUD.style.display='block'; } };
  }
  function handleSignal(m){
    if(m.t==='offer' && role==='join' && m.code===currentCode){
      rtc=makeRTC(); rtc.setRemoteDescription(m.sdp).then(async()=>{ const ans=await rtc.createAnswer(); await rtc.setLocalDescription(ans); await waitICE(rtc); sendSig({t:'answer', code:currentCode, sdp:rtc.localDescription}); closeOverlay(); });
    } else if(m.t==='answer' && role==='host' && m.code===currentCode){
      rtc.setRemoteDescription(m.sdp); closeOverlay();
    } else if(m.t==='err'){ popup(m.msg||'Signal error','#ef4444'); }
  }
  async function hostOnline(){ role='host'; currentCode=mkCode();
    try{ await connectSignal(); rtc=makeRTC(); const offer=await rtc.createOffer(); await rtc.setLocalDescription(offer); await waitICE(rtc);
      sendSig({t:'host', code:currentCode}); sendSig({t:'offer', code:currentCode, sdp:rtc.localDescription});
      popup('Invite Code: '+currentCode,'#7dd3fc'); const box=$('codeBox'), copy=$('copyCode'); if(box) box.value=currentCode; if(copy){ copy.disabled=false; copy.onclick=()=>{ navigator.clipboard.writeText(currentCode); popup('Code copied','#7dd3fc'); }; } }
    catch{ popup('Signal connect failed','#ef4444'); }
  }
  async function joinOnline(code){ role='join'; currentCode=code; try{ await connectSignal(); sendSig({t:'join', code}); }catch{ popup('Signal connect failed','#ef4444'); } }
  function onlineMenu(){ openOverlay(`<div class='row'><div class='title'>Online Co-op</div></div>
    <label class='tiny'>Invite Code (click copy after hosting)</label>
    <div class='row'>
      <input id='codeBox' placeholder='(none yet)' readonly
             style='flex:1;min-width:160px;background:#0b0d17;color:#e5e7eb;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:6px 8px'>
      <button id='copyCode' disabled>Copy</button>
    </div>
    <div class='opts'>
      <div class='opt' id='host'><div class='title'>Host a Game</div><div class='tiny'>Generate code and share it.</div></div>
      <div class='opt'>
        <div class='title'>Join a Game</div>
        <input id='code' maxlength='6' placeholder='ABC123'
               style='width:140px;background:#0b0d17;color:#e5e7eb;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:6px 8px'>
        <button id='joinBtn'>Join</button>
      </div>
    </div>
    <div class='actions'><button data-close>Close</button></div>`);
    const codeEl=modal.querySelector('#code'), joinBtn=modal.querySelector('#joinBtn'),
          codeBox=modal.querySelector('#codeBox'), copyBtn=modal.querySelector('#copyCode');
    if(currentCode){ codeBox.value=currentCode; copyBtn.disabled=false; copyBtn.onclick=()=>{ navigator.clipboard.writeText(currentCode); popup('Code copied','#7dd3fc'); }; }
    modal.querySelector('#host').onclick=hostOnline;
    joinBtn.onclick=()=>{ const c=(codeEl.value||'').trim().toUpperCase(); if(/^[A-Z0-9]{6}$/.test(c)) joinOnline(c); else popup('Invalid code','#ef4444'); };
  }
  function isCoop(){ return !!ally && !!chan && chan.readyState==='open'; }
  function reviveSelf(){ dead=false; paused=false; player.hp=Math.round(player.maxHp*0.6); player.sh=player.maxSh; player.invul=1.0; popup('Revived!','#34d399'); }
  function buybackTeammate(){ if(!remoteDown) return; if(player.coins<reviveCost){ popup('Need '+reviveCost,'#ef4444'); return; }
    player.coins-=reviveCost; coinsLbl.textContent=player.coins; revivesBought++; reviveCost=Math.min(9999, Math.floor(reviveCost*1.6+25));
    try{ chan&&chan.readyState==='open'&&chan.send(JSON.stringify({t:'revive'})); }catch{} remoteDown=false; popup('Bought back teammate!','#34d399'); }
  // Camera & minimap
  const cam={x:player.x-300,y:player.y-200};
  function drawMinimap(){
    const w=world.w,h=world.h; mctx.clearRect(0,0,minimap.width,minimap.height);
    mctx.fillStyle='rgba(255,255,255,.06)'; mctx.fillRect(0,0,minimap.width,minimap.height);
    const sx=minimap.width/w, sy=minimap.height/h;
    const dot=(x,y,c)=>{ mctx.fillStyle=c; mctx.beginPath(); mctx.arc(x*sx,y*sy,3,0,Math.PI*2); mctx.fill(); };
    for(const e of enemies) dot(e.x,e.y,'#ef4444');
    for(const L of loots)   dot(L.x,L.y,'#ffae28');
    dot(player.x,player.y,'#22c55e'); if(ally) dot(ally.x,ally.y,'#60a5fa');
  }

  // Loop
  function startGame(){ applyTalents(); setWeaponUI(player.guns[player.slot-1], player.slot); spawnWave(); last=now(); requestAnimationFrame(step); }
  ensureProfile(startGame);

  let last=now();
  function step(){
    if(paused){ draw(); requestAnimationFrame(step); return; }
    const t=now(), dt=Math.min(0.033, t-last); last=t;
    update(dt); draw(); if(chan && chan.readyState==='open'){ try{ chan.send(JSON.stringify({t:'pos', x:player.x, y:player.y, hp:player.hp, sh:player.sh})); }catch{} }
    requestAnimationFrame(step);
  }

  function onPlayerDown(){ if(isCoop()){ dead=true; paused=true; msg.textContent='You are down! Teammate can buy you back…'; try{ chan&&chan.readyState==='open'&&chan.send(JSON.stringify({t:'down'})); }catch{} } else { gameOver(); } }
  function gameOver(){ dead=true; paused=true; msg.textContent='You fell in the Dust. Press Enter to restart.'; popup('Game Over','#ef4444'); const h=(e)=>{ if(e.key==='Enter'){ removeEventListener('keydown',h); localStorage.removeItem('vaultborn_save'); location.reload(); } }; addEventListener('keydown',h); }

  function update(dt){
    // movement & actions
    const k=keys; let dx=(k['a']?-1:0)+(k['d']?1:0), dy=(k['w']?-1:0)+(k['s']?1:0); const len=Math.hypot(dx,dy)||1; dx/=len; dy/=len;
    const sp=(k['shift']?player.spd*0.75:player.spd) * (mods.spdMult||1);
    player.x=clamp(player.x+dx*sp*dt,40,world.w-40); player.y=clamp(player.y+dy*sp*dt,40,world.h-40);
    if(mouse.down) fire(player);
    if(k['r'] && player.reloadCD<=0){ const g=player.guns[player.slot-1]; if(g && g.mag<g.maxMag){ player.reloadCD=g.reload; popup('Reloading…','#93c5fd'); }}
    if(k['1']){ player.slot=1; setWeaponUI(player.guns[0],1); }
    if(k['2']){ player.slot=2; setWeaponUI(player.guns[1]||player.guns[0],2); }
    if(k['q']){ keys['q']=false; throwGrenade(player); }
    if(k['e']){ keys['e']=false; dash(player); }
    if(k['b']){ keys['b']=false; if(remoteDown) buybackTeammate(); }

    // ally HUD visibility
    allyHUD.style.display = (ally && chan && chan.readyState==='open' && !remoteDown) ? 'block':'none';
    if(ally){ hpBar2.style.width=`${Math.floor(100*ally.hp/ally.maxHp)}%`; shBar2.style.width=`${Math.floor(100*ally.sh/ally.maxSh)}%`;
      hpTxt2.textContent=`${Math.max(0,Math.round(ally.hp))}/${ally.maxHp}`; shTxt2.textContent=`${Math.max(0,Math.round(ally.sh))}/${ally.maxSh}`; }

    // cooldowns/regen
    for(const a of [player, ally].filter(Boolean)){
      a.fireCD=Math.max(0,a.fireCD-dt); a.reloadCD=Math.max(0,a.reloadCD-dt);
      a.dashCD=Math.max(0,a.dashCD-dt); a.grenadeCD=Math.max(0,a.grenadeCD-dt); a.invul=Math.max(0,a.invul-dt);
      if(a.reloadCD===0){ const g=a.guns[a.slot-1]; if(g && g.mag===0){ g.mag=g.maxMag; if(a===player) popup('Reloaded','#34d399'); }}
      a.shCD=Math.max(0,a.shCD-dt); if(a.shCD===0 && a.sh<a.maxSh){ a.sh=clamp(a.sh+a.shRegen*dt,0,a.maxSh); }
    }

    // bullets vs enemies
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt;
      if(b.life<=0){ 
        if(b.aoe) explode(b.x,b.y,b.aoe,b.dmg,b.src);
        bullets.splice(i,1); continue; 
      }
      let hit=false;
      for(let j=enemies.length-1;j>=0;j--){
        const e=enemies[j]; if(dist2(b.x,b.y,e.x,e.y) <= (e.r*e.r)){
          if(b.aoe){
            explode(b.x,b.y,b.aoe,b.dmg,b.src);
          }else{
            e.hp -= b.dmg;
            if(mods.lifesteal>0 && b.src==='me'){ const heal=b.dmg*mods.lifesteal*0.2; let r=heal;
              const addS=Math.min(player.maxSh-player.sh, r); player.sh+=addS; r-=addS;
              player.hp=clamp(player.hp+r,0,player.maxHp); 
            }
            if(e.hp<=0) killEnemy(j);
          }
          effects.push({x:e.x,y:e.y,t:0,kind:'hit'}); bullets.splice(i,1); hit=true; break;
        }
      }
      if(hit) continue;
    }

    // enemy AI & contact
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i]; e.t+=dt;
      const tA=ally? (dist2(e.x,e.y,ally.x,ally.y)<dist2(e.x,e.y,player.x,player.y)?ally:player) : player;
      const a=Math.atan2((tA.y)-e.y, (tA.x)-e.x); const spd=e.boss?e.spd*0.6:e.spd; e.x+=Math.cos(a)*spd*dt; e.y+=Math.sin(a)*spd*dt;
      if(e.boss){ e.atk-=dt; if(e.atk<=0){ e.atk=2; effects.push({x:e.x,y:e.y,t:0,kind:'boom'}); for(let k=0;k<24;k++){ const ang=(k/24)*Math.PI*2; ebullets.push({x:e.x,y:e.y,vx:Math.cos(ang)*220,vy:Math.sin(ang)*220,life:2}); } if(shakeOn) shake=6; } }
      for(const A of [player, ally].filter(Boolean)){
        if(dist2(e.x,e.y,A.x,A.y) <= (e.r+A.r)*(e.r+A.r)){
          if(A.invul<=0){ let dmg=(e.boss?24:10)+wave*2; dmg=Math.max(0.001,dmg*(1-(mods.dmgRes||0)));
            if(A.sh>0){ const take=Math.min(A.sh,dmg); A.sh-=take; dmg-=take; }
            A.hp-=dmg; A.shCD=3; if(A===player) popup('-'+((e.boss?24:10)+wave*2),'#ef4444'); if(A.hp<=0){ if(A===player){ onPlayerDown(); return; } else { remoteDown=true; allyHUD.style.display='none'; } }
          } e.x-=Math.cos(a)*30; e.y-=Math.sin(a)*30;
        }
      }
    }

    // enemy bullets vs heroes
    for(let i=ebullets.length-1;i>=0;i--){
      const b=ebullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0){ ebullets.splice(i,1); continue; }
      for(const A of [player, ally].filter(Boolean)){
        if(dist2(b.x,b.y,A.x,A.y) <= (A.r*A.r)){
          if(A.invul<=0){ let dmg=14+wave*1.5; dmg=Math.max(0.001,dmg*(1-(mods.dmgRes||0)));
            if(A.sh>0){ const take=Math.min(A.sh,dmg); A.sh-=take; dmg-=take; }
            A.hp-=dmg; A.shCD=3; if(A===player) popup('-'+Math.round(14+wave*1.5),'#ef4444'); if(A.hp<=0){ if(A===player){ onPlayerDown(); return; } else { remoteDown=true; allyHUD.style.display='none'; } }
          } ebullets.splice(i,1); break;
        }
      }
    }

    // effects
    for(let i=effects.length-1;i>=0;i--){
      const ef=effects[i]; ef.t+=dt;
      if(ef.kind==='nade'){ const o=ef.obj; o.x+=o.vx*dt; o.y+=o.vy*dt; o.vx*=0.985; o.vy*=0.985; if(ef.t>0.4) effects.splice(i,1); }
      else if(ef.kind==='hit' && ef.t>0.5) effects.splice(i,1);
      else if((ef.kind==='boom'||ef.kind==='spark') && ef.t>0.9) effects.splice(i,1);
    }

    // loot proximity
    let near=false, nearI=-1, best=1e9;
    for(let i=loots.length-1;i>=0;i--){ const L=loots[i]; L.t+=dt; const d2=dist2(player.x,player.y,L.x,L.y); const d2b=ally?dist2(ally.x,ally.y,L.x,L.y):1e9; const dd=Math.min(d2,d2b);
      if(dd<(28*28) && dd<best){ near=true; nearI=i; best=dd; } if(L.t>180) loots.splice(i,1); }
    lootHint.style.opacity=near?1:0;
    if(near){ if(keys['f']){ keys['f']=false; const L=loots.splice(nearI,1)[0]; pickup(L.item); } if(autoPickup){ const L=loots.splice(nearI,1)[0]; if(L) pickup(L.item); } }

    // camera & bars & minimap
    cam.x=lerp(cam.x, player.x - canvas.width/devicePixelRatio/2, 0.12);
    cam.y=lerp(cam.y, player.y - canvas.height/devicePixelRatio/2, 0.12);
    hpBar.style.width=`${Math.floor(100*player.hp/player.maxHp)}%`;
    shBar.style.width=`${Math.floor(100*player.sh/player.maxSh)}%`;
    xpBar.style.width=`${Math.floor(100*player.xp/player.nextXP)}%`;
    hpTxt.textContent=`${Math.max(0,Math.round(player.hp))}/${player.maxHp}`;
    shTxt.textContent=`${Math.max(0,Math.round(player.sh))}/${player.maxSh}`;
    xpTxt.textContent=`${Math.floor(player.xp)}/${player.nextXP}`;
    drawMinimap();
  }

  function pickup(item){
    popup(`Picked ${item.rarity} ${item.type}`, item.rColor);
    const cur=player.guns[player.slot-1];
    if(dps(item)>dps(cur)){ player.guns[player.slot-1]=item; setWeaponUI(item, player.slot); msg.textContent='Auto-equipped better weapon.'; }
    else{ const other=player.slot===1?2:1;
      if(!player.guns[other-1] || dps(item)>dps(player.guns[other-1])){ player.guns[other-1]=item; msg.textContent=`Stored in slot ${other}.`; }
      else msg.textContent='Kept current loadout.'; }
    beep(700,0.05,'sine',0.03); save();
  }
  function killEnemy(i,byExplosion=false){
    const e=enemies[i]; enemies.splice(i,1); left=Math.max(0,left-1); leftLbl.textContent=left;
    const dropChance=0.25 + wave*0.01 + (byExplosion?0.05:0) + (mods.dropPlus||0);
    if(chance(dropChance)){ const item=rollWeapon(player.level + (chance(0.15)?2:0)); loots.push({x:e.x,y:e.y,r:12,item,t:0}); effects.push({x:e.x,y:e.y,t:0, kind:'spark', c:item.rColor}); }
    const bonus=ally?1.2:1; player.coins+=Math.round((bossWave?20:5)*bonus); coinsLbl.textContent=player.coins;
    addXP(bossWave?120:25);
    if(left===0){ if(!endless && wave===5){ endless=true; msg.textContent='Vault opened! Endless Rift unlocked.'; }
      openShop(()=>{ wave+=1; spawnWave(); }); }
  }

  // Draw
  function draw(){
    const w=canvas.width/devicePixelRatio, h=canvas.height/devicePixelRatio;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    let sx=0, sy=0; if(shake>0){ sx=(Math.random()-0.5)*shake; sy=(Math.random()-0.5)*shake; shake*=0.9; if(shake<0.5) shake=0; }
    ctx.save(); ctx.translate(-cam.x%80+sx, -cam.y%80+sy); ctx.strokeStyle='rgba(255,255,255,.04)';
    for(let x=-80;x<w+80;x+=80){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h+80); ctx.stroke(); }
    for(let y=-80;y<h+80;y+=80){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w+80,y); ctx.stroke(); }
    ctx.restore();
    for(const L of loots){ ctx.beginPath(); ctx.arc(L.x-cam.x+sx,L.y-cam.y+sy,L.r,0,Math.PI*2); ctx.fillStyle=L.item.rColor; ctx.globalAlpha=0.85; ctx.fill(); ctx.globalAlpha=1; }
    for(const e of enemies){ ctx.beginPath(); ctx.arc(e.x-cam.x+sx,e.y-cam.y+sy,e.r,0,Math.PI*2); ctx.fillStyle=e.boss?'#f87171':'#b91c1c'; ctx.fill();
      const bw=e.r*2, bh=4; ctx.fillStyle='#0b0d17'; ctx.fillRect(e.x-cam.x-e.r+sx, e.y-cam.y-e.r-10+sy, bw, bh);
      ctx.fillStyle=e.boss?'#f87171':'#ef4444'; ctx.fillRect(e.x-cam.x-e.r+sx, e.y-cam.y-e.r-10+sy, bw*clamp(e.hp/e.max,0,1), bh); }
    ctx.fillStyle='#fbbf24'; for(const b of bullets){ ctx.fillRect(b.x-cam.x-2+sx,b.y-cam.y-2+sy,4,4); }
    ctx.fillStyle='#93c5fd'; for(const b of ebullets){ ctx.fillRect(b.x-cam.x-2+sx,b.y-cam.y-2+sy,4,4); }
    for(const ef of effects){
      if(ef.kind==='hit'){ ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.beginPath(); ctx.arc(ef.x-cam.x+sx,ef.y-cam.y+sy,8*ef.t,0,Math.PI*2); ctx.stroke(); }
      else if(ef.kind==='boom'){ ctx.fillStyle='rgba(245,158,11,.35)'; ctx.beginPath(); ctx.arc(ef.x-cam.x+sx,ef.y-cam.y+sy,120,0,Math.PI*2); ctx.fill(); }
      else if(ef.kind==='spark'){ ctx.fillStyle=ef.c||'#fff'; ctx.beginPath(); ctx.arc(ef.x-cam.x+sx,ef.y-cam.y+sy,10,0,Math.PI*2); ctx.fill(); }
      else if(ef.kind==='nade'){ const o=ef.obj; ctx.fillStyle='#93c5fd'; ctx.beginPath(); ctx.arc(o.x-cam.x+sx,o.y-cam.y+sy,6,0,Math.PI*2); ctx.fill(); }
    }
    ctx.beginPath(); ctx.arc(player.x-cam.x+sx,player.y-cam.y+sy,player.r,0,Math.PI*2); ctx.fillStyle='#22c55e'; ctx.fill();
    if(ally){ ctx.beginPath(); ctx.arc(ally.x-cam.x+sx,ally.y-cam.y+sy,ally.r,0,Math.PI*2); ctx.fillStyle='#60a5fa'; ctx.fill(); }
  }
})();
</script>
</body>
</html>
